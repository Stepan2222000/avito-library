# План реализации: Детектор серверных ошибок 5xx

## Общее описание

Реализуем обработку серверных ошибок HTTP (502 Bad Gateway, 503 Service Unavailable, 504 Gateway Timeout) в библиотеке avito-library. Эти ошибки означают временную недоступность сервера Avito и должны обрабатываться через автоматический retry с exponential backoff.

**Ключевое решение:** Создаём один детектор для всех 5xx ошибок (не три отдельных), который возвращает единый ID. Это упрощает архитектуру и соответствует паттерну `removed_or_not_found_detector`, который обрабатывает сразу 404 и 410.

---

## Этап 1: Создание детектора server_error_5xx_detector

### Цель
Создать детектор, который определяет серверные ошибки по HTTP статус-коду ответа.

### Файл
`avito_library/detectors/server_error_5xx_detector.py`

### Описание логики

Детектор принимает два параметра: объект страницы Playwright и опциональный объект HTTP-ответа. Основная логика — проверка статус-кода ответа.

Если статус-код находится в диапазоне от 500 до 599 включительно (то есть любая серверная ошибка), детектор срабатывает и возвращает свой идентификатор. При срабатывании сохраняется отладочный скриншот с меткой, содержащей конкретный статус-код (например, "detector-server-error-502").

Если ответ отсутствует или статус-код не в диапазоне 5xx, детектор возвращает False и не влияет на дальнейшую цепочку детектирования.

### Константы модуля
- `DETECTOR_ID` — строка "server_error_5xx_detector", используется как уникальный идентификатор состояния

### Отличие от других детекторов
В отличие от `proxy_block_403_detector` и `proxy_block_429_detector`, этот детектор не проверяет HTML-содержимое страницы. Серверные ошибки 5xx — это стандартные ответы от nginx/cloudflare, которые однозначно определяются по HTTP статус-коду. Дополнительная проверка DOM не требуется.

---

## Этап 2: Регистрация детектора в системе

### Цель
Интегрировать новый детектор в реестр и настроить его приоритет.

### Файл 1: avito_library/detectors/__init__.py

В этом файле выполняется три действия:

**Действие 1: Импорт компонентов**
Добавляем импорт функции детектора и её константы ID. Импорт размещаем после существующих детекторов прокси-ошибок, сохраняя логическую группировку.

**Действие 2: Регистрация в словаре DETECTOR_FUNCTIONS**
Добавляем пару "идентификатор — функция" в словарь. Это позволяет роутеру detect_page_state находить и вызывать детектор по его ID.

**Действие 3: Определение приоритета в DETECTOR_DEFAULT_ORDER**
Добавляем ID детектора на вторую позицию в кортеже приоритетов.

Итоговый порядок приоритетов будет таким:
1. proxy_block_403_detector — блокировка IP (самая критичная, прокси нужно менять)
2. server_error_5xx_detector — серверная ошибка (временная, нужен retry)
3. proxy_block_429_detector — rate limit (решается через капчу/ожидание)
4. proxy_auth_407_detector — требуется авторизация прокси
5. captcha_geetest_detector — капча
6. и далее остальные детекторы

Логика такого порядка: сначала проверяем критические ошибки прокси (403), затем временные ошибки сервера (5xx), затем rate limit (429). Это позволяет быстро классифицировать проблему и выбрать правильную стратегию.

**Действие 4: Экспорт константы**
Добавляем `SERVER_ERROR_5XX_DETECTOR_ID` в список `__all__` для публичного доступа.

### Файл 2: avito_library/detectors/detect_page_state.py

В этом файле есть множество `last_response_detectors`, которое определяет, какие детекторы получают HTTP-ответ как параметр.

Добавляем строку "server_error_5xx_detector" в это множество. После этого роутер будет автоматически передавать `last_response` при вызове нашего детектора.

### Файл 3: avito_library/__init__.py

Добавляем импорт и экспорт константы `SERVER_ERROR_5XX_DETECTOR_ID` для доступа из пользовательского кода. Это позволит пользователям библиотеки проверять состояние:

```python
if state == SERVER_ERROR_5XX_DETECTOR_ID:
    # обработка серверной ошибки
```

---

## Этап 3: Добавление статуса SERVER_UNAVAILABLE

### Цель
Создать статус для возврата, когда все retry-попытки исчерпаны.

### Обоснование нового статуса

Существующие статусы не подходят по семантике:
- `LOAD_TIMEOUT` — означает, что истёк таймаут загрузки страницы, а не ошибку сервера
- `PAGE_NOT_DETECTED` — означает, что не удалось определить тип страницы, но страница загрузилась
- `PROXY_BLOCKED` — вводит в заблуждение, потому что прокси работает корректно, проблема на стороне сервера Avito

Новый статус `SERVER_UNAVAILABLE` точно описывает ситуацию: сервер вернул ошибку 5xx и остаётся недоступен после нескольких попыток.

### Файл 1: avito_library/parsers/catalog_parser/models.py

Добавляем новое значение `SERVER_UNAVAILABLE = "server_unavailable"` в enum `CatalogParseStatus`.

### Файл 2: avito_library/parsers/card_parser.py

Добавляем новое значение `SERVER_UNAVAILABLE = "server_unavailable"` в enum `CardParseStatus`.

### Для seller_profile_parser

Этот парсер возвращает словарь, а не enum. Для обозначения серверной ошибки используем строку "server_unavailable" в поле "state".

---

## Этап 4: Исправление потери Response в catalog_parser

### Цель
Исправить архитектурный недостаток — сохранять HTTP-ответ и передавать его в detect_page_state.

### Проблема

Сейчас в `catalog_parser_v2.py` происходит следующее:

1. Вызывается `navigate_to_catalog()`, которая возвращает объект Response
2. Этот Response **не сохраняется** — вызов происходит без присваивания результата
3. Далее вызывается `detect_page_state(page)` **без параметра last_response**
4. В результате детекторы 403/429/407/404 работают только по HTML-маркерам, без проверки HTTP-статусов

Это технический долг, который нужно исправить для корректной работы детектора 5xx.

### Файл
`avito_library/parsers/catalog_parser/catalog_parser_v2.py`

### Описание изменений

**Изменение 1: Начальная навигация в parse_catalog**

При первой навигации на страницу каталога сохраняем Response в переменную. Затем передаём эту переменную в detect_page_state. Это касается места примерно на строке 435, где вызывается navigate_to_catalog.

**Изменение 2: Навигация на следующие страницы**

В цикле пагинации (примерно строки 580-615) также сохраняем Response от navigate_to_catalog и передаём в последующие вызовы detect_page_state.

**Изменение 3: Обработка reload**

При retry нам нужно будет делать page.reload(). Метод reload() также возвращает Response, который нужно сохранить и передать в detect_page_state.

### Побочный эффект

После этого исправления существующие детекторы (403, 429, 407, 404) начнут работать точнее, потому что смогут проверять HTTP статус-коды напрямую, а не только HTML-маркеры.

---

## Этап 5: Добавление retry-логики в catalog_parser

### Цель
Автоматически повторять запрос при серверных ошибках.

### Файл
`avito_library/parsers/catalog_parser/catalog_parser_v2.py`

### Параметры retry

- **Количество попыток:** 3
- **Задержки между попытками:** 2, 4, 8 секунд (exponential backoff)
- **Общее максимальное время ожидания:** 14 секунд

Эти параметры выбраны так, чтобы дать серверу время восстановиться, но не блокировать парсинг слишком долго.

### Место 1: В функции parse_single_page

После вызова detect_page_state проверяем, вернулся ли идентификатор серверной ошибки. Если да — входим в цикл retry.

Логика цикла:
1. Увеличиваем счётчик попыток
2. Вычисляем задержку как 2 в степени номера попытки (2, 4, 8 секунд)
3. Ждём указанное время
4. Вызываем page.reload() для повторного запроса
5. Сохраняем Response от reload
6. Вызываем detect_page_state с новым Response
7. Если состояние изменилось — выходим из цикла
8. Если все попытки исчерпаны и состояние всё ещё 5xx — возвращаем результат со статусом SERVER_UNAVAILABLE

Этот цикл размещается **до** цикла решения капчи, потому что нет смысла решать капчу, если сервер недоступен.

### Место 2: В главном цикле parse_catalog при навигации

В существующем блоке retry для PlaywrightTimeout добавляем проверку Response. После успешной навигации (без таймаута) проверяем статус-код ответа.

Если статус в диапазоне 5xx — не выходим из цикла retry, а продолжаем следующую итерацию. Это позволит использовать существующую инфраструктуру retry (параметр load_retries, по умолчанию 5 попыток).

### Взаимодействие с капчей

Важно понимать порядок обработки:
1. Сначала проверяем 5xx и делаем retry если нужно
2. Затем проверяем капчу и решаем если нужно
3. Затем проверяем другие состояния

Если после retry 5xx появилась капча — это нормально, переходим к её решению. Если после решения капчи снова 5xx — снова retry.

---

## Этап 6: Добавление retry-логики в card_parser

### Цель
Реализовать аналогичную обработку в парсере карточек.

### Файл
`avito_library/parsers/card_parser.py`

### Описание изменений

Парсер карточек отличается от catalog_parser тем, что не делает навигацию внутри — страница уже открыта, и Response передаётся как параметр функции parse_card.

После вызова detect_page_state добавляем цикл retry для серверных ошибок. Логика аналогична catalog_parser:

1. Проверяем, равен ли state идентификатору SERVER_ERROR_5XX_DETECTOR_ID
2. Если да — входим в цикл (максимум 3 итерации)
3. В каждой итерации: ждём, делаем reload, получаем новый Response, вызываем detect_page_state
4. Если состояние изменилось — продолжаем обычную обработку
5. Если все попытки исчерпаны — возвращаем CardParseResult со статусом SERVER_UNAVAILABLE

### Важный нюанс

После reload нужно получить новый HTML для парсинга. Поэтому если retry успешен (состояние изменилось на CARD_FOUND), парсинг HTML происходит как обычно.

---

## Этап 7: Добавление обработки в seller_profile_parser

### Цель
Обработать серверные ошибки в парсере профиля продавца.

### Файл
`avito_library/parsers/seller_profile_parser.py`

### Особенность этого парсера

seller_profile_parser работает иначе: он сначала детектирует профиль, потом делает API-запросы для получения списка товаров. Поэтому обработка 5xx нужна в двух местах.

### Место 1: Начальная детекция профиля

В функции collect_seller_items после вызова detect_page_state добавляем проверку на серверную ошибку. Логика retry аналогична другим парсерам.

Если после всех попыток состояние остаётся 5xx — возвращаем словарь с полем "state" равным "server_unavailable".

### Место 2: API-запросы в _fetch_profile_items

Функция _fetch_profile_items делает HTTP-запросы к API Avito через page.evaluate с fetch. Эти запросы тоже могут вернуть 5xx ошибку.

Добавляем проверку статус-кода ответа API. Если статус в диапазоне 5xx — повторяем запрос с exponential backoff. Используем те же параметры: 3 попытки, задержки 2/4/8 секунд.

Если все попытки исчерпаны — возвращаем None или специальный маркер ошибки, который обработается в вызывающем коде.

### Дополнительное улучшение

Сейчас seller_profile_parser не обрабатывает состояния 403 и 407 — они попадают в ветку "unexpected state". При реализации 5xx логично добавить и их обработку: возвращать соответствующие состояния ("proxy_blocked" / "proxy_auth_required") вместо общего "unexpected".

---

## Этап 8: Обновление документации

### Цель
Отразить изменения в документации проекта.

### Файл 1: CLAUDE.md

**Таблица детекторов**
Добавить строку с новым детектором:
- Файл: server_error_5xx_detector.py
- ID: server_error_5xx_detector
- Назначение: HTTP 502/503/504 серверные ошибки

**Порядок приоритета**
Обновить список, добавив server_error_5xx_detector на вторую позицию.

**Главный API**
Добавить константу SERVER_ERROR_5XX_DETECTOR_ID в список экспортируемых компонентов.

### Файл 2: README.md

**Раздел CatalogParseStatus**
Добавить описание статуса SERVER_UNAVAILABLE с пояснением, когда он возвращается.

**Раздел CardParseStatus**
Аналогично добавить SERVER_UNAVAILABLE.

**Раздел обработки ошибок**
Добавить пример кода, показывающий как обрабатывать серверные ошибки:
- Проверка на SERVER_UNAVAILABLE статус
- Рекомендация подождать и повторить позже

---

## Порядок выполнения

1. **Детектор** — создаём файл, это независимая единица
2. **Регистрация** — подключаем детектор к системе
3. **Статусы** — добавляем новые значения в enum
4. **catalog_parser Response** — исправляем потерю Response
5. **catalog_parser retry** — добавляем логику повторов
6. **card_parser** — добавляем статус и retry
7. **seller_profile_parser** — добавляем обработку
8. **Документация** — фиксируем изменения

Этапы 1-3 можно выполнить параллельно (независимы друг от друга). Этапы 4-7 выполняются последовательно, потому что каждый следующий зависит от предыдущего. Этап 8 выполняется в конце.

---

## Файлы для изменения (итого)

| Файл | Действие |
|------|----------|
| `detectors/server_error_5xx_detector.py` | Создать новый файл |
| `detectors/__init__.py` | Импорт, регистрация, приоритет, экспорт |
| `detectors/detect_page_state.py` | Добавить в last_response_detectors |
| `avito_library/__init__.py` | Импорт и экспорт константы |
| `parsers/catalog_parser/models.py` | Добавить SERVER_UNAVAILABLE |
| `parsers/catalog_parser/catalog_parser_v2.py` | Сохранение Response + retry |
| `parsers/card_parser.py` | Статус + retry |
| `parsers/seller_profile_parser.py` | Retry в двух местах |
| `CLAUDE.md` | Документация детектора |
| `README.md` | Документация статусов |

---

## Тестирование

После реализации проверить:

1. **Детектор работает:** при HTTP 502/503/504 возвращается правильный ID
2. **Retry работает:** при временной 5xx ошибке парсер восстанавливается
3. **Статус возвращается:** если retry исчерпаны — возвращается SERVER_UNAVAILABLE
4. **Существующая функциональность не сломана:** капча, 403, 429 работают как раньше
5. **Response передаётся:** детекторы получают last_response и работают точнее
