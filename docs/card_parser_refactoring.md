# Рефакторинг parse_card: добавление обработки состояний

## Исходная проблема

Текущая функция `parse_card` принимает готовый HTML и просто парсит его. Она не знает о состояниях страницы Avito (капча, блокировки, кнопка "Продолжить").

Это означает, что воркер (внешний код) должен сам:
1. Делать навигацию на страницу карточки
2. Вызывать `detect_page_state` для определения состояния
3. Вызывать `resolve_captcha_flow` если обнаружена капча
4. Получать HTML через `page.content()`
5. Только потом вызывать `parse_card(html)`

При этом `parse_catalog` из библиотеки уже умеет всё это делать автоматически внутри себя.

---

## Что хочет пользователь

Пользователь хочет, чтобы `parse_card` работала по-другому:
- Функция получает страницу (Page) с уже открытой карточкой (навигация сделана снаружи)
- Функция сама делает детекцию состояния
- Функция сама решает капчу если нужно
- Если что-то пошло не так (блокировка, капча не решена) — функция возвращает статус, а не бросает исключение
- Внешний алгоритм (воркер) получает статус и сам решает что делать дальше (сменить прокси, пропустить, retry)

---

## Принятые решения

### Название и расположение
- **Название функции:** `parse_card` (оставить как есть)
- **Файл:** редактировать существующий `avito_library/parsers/card_parser.py`
- **Breaking change:** да, старый API сломается

### Навигация
- Навигация (goto) делается **снаружи** — воркер сам открывает страницу карточки
- Функция получает уже открытую страницу

### Обработка капчи
- Капчу решать **внутри** функции
- Кнопка "Продолжить" (continue_button) — это часть капчи, обрабатывать через `resolve_captcha_flow`
- HTTP 429 (rate limit) — тоже часть капчи, обрабатывать через `resolve_captcha_flow`

### Формат возвращаемого значения
- **Dataclass** — `CardParseResult` с полями status и data
- При ошибке data будет None

### Статусы (CardParseStatus)
Минимальный набор плюс PAGE_NOT_DETECTED:
- **SUCCESS** — карточка успешно спарсена
- **CAPTCHA_FAILED** — капча не решена за отведённое количество попыток
- **PROXY_BLOCKED** — HTTP 403, IP заблокирован
- **NOT_FOUND** — объявление удалено или не найдено (404/410, removed_or_not_found_detector)
- **PAGE_NOT_DETECTED** — неизвестное состояние страницы, детектор не смог определить что это

### Параметры функции
- **page** — Playwright Page, обязательный
- **last_response** — Response от навигации, обязательный, передаётся параметром
- **fields** — какие поля парсить, обязательный (как сейчас)
- **max_captcha_attempts** — максимум попыток решения капчи, настраиваемый, по умолчанию 30

### Метаданные при ошибке
- Возвращать **только статус** — без detector_id, без HTML для отладки
- Простой и минимальный интерфейс

### Особые случаи
- **Попадание на другую страницу (каталог, профиль продавца):** пользователь сказал "такого не может быть" — не обрабатываем этот случай

---

## Логика работы новой функции

### Словесное описание

1. Функция получает страницу с уже открытой карточкой и response от навигации

2. Вызываем детекцию состояния страницы

3. Если состояние — капча, 429 или кнопка "Продолжить":
   - Запускаем цикл решения капчи (до max_captcha_attempts раз)
   - После каждой попытки снова детектируем состояние
   - Если состояние изменилось на не-капчу — выходим из цикла

4. После попыток капчи смотрим финальное состояние:
   - Если карточка найдена — получаем HTML, парсим, возвращаем SUCCESS с данными
   - Если 403 — возвращаем PROXY_BLOCKED
   - Если удалено/не найдено — возвращаем NOT_FOUND
   - Если всё ещё капча — возвращаем CAPTCHA_FAILED
   - Если неизвестное состояние — возвращаем PAGE_NOT_DETECTED

### Какие детекторы к каким статусам

| Детектор | Статус |
|----------|--------|
| card_found_detector | SUCCESS (после парсинга) |
| proxy_block_403_detector | PROXY_BLOCKED |
| proxy_auth_407_detector | PROXY_BLOCKED |
| removed_or_not_found_detector | NOT_FOUND |
| captcha_geetest_detector (после попыток) | CAPTCHA_FAILED |
| continue_button_detector (после попыток) | CAPTCHA_FAILED |
| proxy_block_429_detector (после попыток) | CAPTCHA_FAILED |
| NOT_DETECTED_STATE_ID | PAGE_NOT_DETECTED |

### Состояния которые запускают решение капчи

- captcha_geetest_detector
- proxy_block_429_detector
- continue_button_detector

Все три обрабатываются через `resolve_captcha_flow`.

---

## Что нужно сделать в коде

### Шаг 1: Добавить новые типы

В начало файла `card_parser.py` добавить:
- Enum `CardParseStatus` с пятью значениями
- Dataclass `CardParseResult` с полями status и data

### Шаг 2: Вынести текущую логику парсинга

Текущий код функции `parse_card` (который парсит HTML) переименовать в приватную функцию `_parse_card_html`.

Эта функция будет вызываться внутри новой `parse_card` после успешной детекции карточки.

### Шаг 3: Написать новую parse_card

Новая функция:
- Принимает page, last_response, fields, max_captcha_attempts
- Реализует логику обработки состояний (описана выше)
- Возвращает CardParseResult

### Шаг 4: Добавить нужные импорты

Нужно импортировать:
- Page и Response из playwright
- detect_page_state и константы детекторов
- resolve_captcha_flow

### Шаг 5: Обновить экспорты

В `__all__` файла добавить CardParseStatus и CardParseResult.

В главном `__init__.py` библиотеки добавить экспорт новых типов.

---

## Пример использования после рефакторинга

Воркер будет использовать функцию так:

1. Воркер делает навигацию на карточку и получает response
2. Воркер вызывает parse_card с page, response и списком полей
3. Воркер проверяет статус результата
4. Если SUCCESS — использует данные
5. Если ошибка — обрабатывает по-своему (смена прокси, пропуск, логирование)

---

## Что НЕ меняется

- Вся логика парсинга HTML (извлечение полей, скачивание картинок) остаётся
- CardData остаётся без изменений
- CardParsingError остаётся (может использоваться внутри)
- Все helper-функции (_extract_title, _extract_price и т.д.) остаются

---

## Зависимости

Функция будет использовать:
- `detect_page_state` из `avito_library.detectors`
- `resolve_captcha_flow` из `avito_library.capcha`
- Константы детекторов (CAPTCHA_DETECTOR_ID, CARD_FOUND_DETECTOR_ID и т.д.)
